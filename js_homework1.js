//Якщо до строки додавати число - число переведеться в строку та відбудеться конкатинація строк. В даному випадку отримаєм строку "number33"
console.log('number' + 3 + 3)

//null при переведені в число дає 0. В результаті отримаєм 3
console.log(null + 3)

/*
Тут я думав що ми виведем true, бо якщо перевести обидва значення в буліан буде true && true, що дасть true
Але && повертає значення, а не резульатат перетворення значення на буліан
Яке саме значення з 2 він поверне? 
-Якщо усі значення при переведенні в буліан будуть true, то останнє. Як тільки буде знайдене перше значення яке буде дорівнювати у переводі на буліан false, то воно і повернеться
Тож тут отримаєм 'qwerty'
*/
console.log(5 && "qwerty")

//Приводим строку "40" за допомогою префіксного +, теж саме робим з "2". Додаем 40 до 2, отримуєм 42. Далі як в 1 прикладі відбувається конкатинація строк та отримуєм строку "42hillel"
console.log(+'40' + +'2' + "hillel");

//При відніманні числа від строки, строка приводиться до числа, у результаті віднімання буде 5. Строго порівнюєм числа 5 і 6. Типи співпадають, значення - ні, отримуєм false
console.log('10' - 5 === 6);

//Якщо сумуються boolean значченя, true відповідає 1, false - 0. У результаті отримаєм число 1
console.log(true + false);

//Якщо від строки яку не можна перевести в число відняти число отримаєм NaN
console.log('4px' - 3)

//Якщо від строки яку можна перевести в число відняти число отримаєм число. В даному прикладі отримаєм число 1
console.log('4' - 3);

//3 ** 0 означає 3 в 0 ступіні, що дорівнює 1. При додавані строки до числа відбудеться конкатинація строк і отримаєм строку "61"
console.log('6' + 3 ** 0);

//При діленні числа на строку, строка приводиться до числа, у результаті ділення буде 2
console.log(12 / '6')

//5 строго порівнюєм з 6, отримуєм false. При додаванні строки до буліана, буліан переводиться в строку. Далі буде конкатинація строк та отримаєм cтроку '10false'
console.log('10' + (5 === 6));

/*
null i строка різні за типами, але ми робим на суворе порівняння і якщо перевести обидва занчення в числа отримаєм 0, 0 == 0 тож отримаєм true
так я думав^,   але мені дало false і я дізнався, що в js тілик null == undefined дасть true, в інших випадках null не буде приводитись до типу значення з яким порівнюється, тобто:
null == 0 → false
null == "" → false
null == false → false
*/
console.log(null == '');

//Спочатку робим дію в скобках, 9/3 = 3, потім число 3 зводимо у 3 ступінь і отримуєм 27
console.log(3 ** (9 / 3));

//За допомогою !! в js можна привести значення до буліану. Буліан "false" -> true. Буліан "true" -> true. Не суворо порівнюєм true == true, отримуєм true
console.log(!!'false' == !!'true')

/*
Спочатку &&, бо вищий пріорітет
'0' в переводі до буліан це true, 1 теж true, тож в результаті виразу '0' && 1 отримуєм 1
Отримуєм вираз 0 || 1
|| буде шукати перше значення яке в переводі на буліан дасть true. 0 в переводі до буліан це false, 1 це true, тож в результаті отримуєм 1
*/
console.log(0 || '0' && 1);

//Привобим null до числа. При не суворму порівнянні 0 і false отримуєм true. Далі порівнюєм true < 1, true при перетворенні на число дає 1, а 1 не менше 1, тож отримуєм false
console.log((+null == false) < 1);

//&& має вищий пріорітет ніж ||. false && true дасть false. Далі false || true дасть true
console.log(false && true || true)

//Те що в () має вищий пріорітет, тож false || true дасть true. Далі false && true дасть false
console.log(false && (false || true));

//Тут так само як двома прикладами вище, тільки число 1 справа від знаку порівняння треба звести у 5 ступінь, а так теж самий приклад. В результаті отримаєм false
console.log((+null == false) < 1 ** 5);